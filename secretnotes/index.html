<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#000000" />
  <title>SecretNotes</title>
  
  <!-- FAVICON INISIAL JB -->
  <link rel="icon" type="image/svg+xml" href="image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32'><rect width='32' height='32' fill='%23000'/><text x='16' y='22' font-family='Courier New' font-size='18' fill='%2300ff00' text-anchor='middle'>JB</text></svg>">

  <style>
    :root {
      --bg: #000000;
      --sidebar-bg: #000000;
      --card: #000000;
      --text: #00ff00;
      --border: #005500;
      --hover: #003300;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Courier New', monospace;
      background: var(--bg);
      color: var(--text);
    }

    .app-container {
      display: flex;
      height: 100vh;
      width: 100vw;
      overflow-x: hidden;
    }

    .sidebar {
      width: 300px;
      background: var(--sidebar-bg);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      flex-shrink: 0;
    }

    .sidebar-header {
      padding: 15px 16px;
      background: #001100;
      border-bottom: 1px solid var(--border);
      text-align: center;
    }

    .sidebar-title {
      font-size: 20px;
      font-weight: bold;
      text-shadow: 0 0 5px var(--text);
      margin: 0 0 10px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .sidebar-buttons {
      display: flex;
      gap: 6px;
      justify-content: center;
      flex-wrap: wrap;
      padding: 0 8px;
      margin: 0 8px 10px;
    }

    .btn-hacker {
      background: #001100;
      color: var(--text);
      border: 1px solid var(--border);
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      font-size: 12px;
      min-width: 36px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .btn-hacker:hover {
      background: #002200;
      box-shadow: 0 0 8px var(--text);
    }

    .btn-danger {
      background: #220000 !important;
      border-color: #550000 !important;
    }

    .btn-danger:hover {
      background: #330000 !important;
      box-shadow: 0 0 8px #ff0000 !important;
    }

    .tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: #000;
      color: #00ff00;
      padding: 4px 8px;
      border: 1px solid #005500;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s;
      pointer-events: none;
      z-index: 100;
    }

    .btn-hacker:hover .tooltip {
      opacity: 1;
      visibility: visible;
    }

    .search-box {
      width: calc(100% - 32px);
      margin: 16px 16px 10px;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: #001100;
      color: var(--text);
      font-size: 14px;
    }

    .tabs {
      display: flex;
      padding: 0 16px 10px;
      border-bottom: 1px solid var(--border);
      justify-content: space-around;
    }

    .tab-btn {
      background: none;
      border: none;
      padding: 6px 12px;
      color: #00aa00;
      font-size: 14px;
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .tab-btn.active {
      color: var(--text);
      font-weight: bold;
      border-bottom: 2px solid var(--text);
      text-shadow: 0 0 5px var(--text);
    }

    .note-list {
      flex-grow: 1;
      overflow-y: auto;
      padding: 0 8px;
    }

    .note-item {
      padding: 12px 12px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.2s;
      overflow: hidden;
      position: relative;
    }

    .note-item:hover {
      background: var(--hover);
    }

    .note-item.selected {
      background: #002200;
      border-left: 4px solid var(--text);
    }

    .pinned-indicator {
      position: absolute;
      left: 8px;
      top: 50%;
      transform: translateY(-50%);
      color: #00ff00;
      font-size: 18px;
      display: none;
    }

    .note-item.pinned .pinned-indicator {
      display: block;
    }

    .note-item.pinned {
      border-left: 4px solid #00ff00;
    }

    .note-title {
      font-weight: bold;
      font-size: 15px;
      color: var(--text);
      margin-bottom: 6px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .note-preview {
      font-size: 13px;
      color: #00aa00;
      line-height: 1.4;
      max-height: 2.8em;
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      word-break: break-word;
    }

    .note-meta {
      font-size: 0.85em;
      color: #007700;
      display: flex;
      justify-content: space-between;
      margin-top: 6px;
    }

    .main-content {
      flex-grow: 1;
      padding: 20px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-width: 0;
    }

    .empty-state {
      flex-grow: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #00aa00;
      font-size: 18px;
    }

    .note-detail {
      display: none;
      flex-direction: column;
      height: 100%;
      min-width: 0;
    }

    .note-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border);
    }

    .note-title-input {
      font-size: 20px;
      font-weight: bold;
      border: none;
      outline: none;
      background: transparent;
      color: var(--text);
      flex-grow: 1;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .note-actions {
      display: flex;
      gap: 8px;
    }

    .note-actions .btn-hacker {
      padding: 6px 12px;
      font-size: 12px;
      min-width: auto;
    }

    #editor-toolbar {
      background: #000000;
      border: 1px solid var(--border);
      border-bottom: none;
      padding: 8px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      overflow-x: auto;
    }

    .toolbar-btn {
      background: #001100;
      color: #00aa00;
      border: 1px solid var(--border);
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      white-space: nowrap;
      min-width: 40px;
    }

    .toolbar-btn:hover {
      background: #002200;
      box-shadow: 0 0 5px #00ff00;
    }

    #editor-container {
      flex-grow: 1;
      border: 1px solid var(--border);
      border-top: none;
      border-radius: 0 0 4px 4px;
      overflow: hidden;
      background: #000000;
    }

    #editor {
      width: 100%;
      height: 100%;
      padding: 12px;
      background: #000000;
      color: #00ff00;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.5;
      outline: none;
      caret-color: #00ff55;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .note-footer {
      margin-top: 15px;
      font-size: 0.9em;
      color: #007700;
      display: flex;
      justify-content: space-between;
      padding-top: 10px;
      border-top: 1px solid var(--border);
    }

    .status-bar {
      position: fixed;
      bottom: 0;
      left: 300px;
      right: 0;
      background: #001100;
      padding: 6px 15px;
      font-size: 0.9em;
      color: #00aa00;
      text-align: center;
      border-top: 1px solid var(--border);
    }

    @media (max-width: 768px) {
      .app-container {
        flex-direction: column;
        height: auto;
        min-height: 100vh;
        width: 100vw;
      }
      
      .sidebar {
        width: 100%;
        border-right: none;
        border-bottom: 1px solid var(--border);
        max-height: 50vh;
        order: 2;
      }
      
      .main-content {
        order: 1;
        padding: 15px;
      }
      
      .status-bar {
        left: 0;
        position: static;
        order: 3;
      }
      
      .sidebar-buttons .btn-hacker {
        min-width: 40px;
        padding: 8px 6px;
        font-size: 11px;
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <div class="sidebar">
      <div class="sidebar-header">
        <div class="sidebar-title">SecretNotes</div>
        <div class="sidebar-buttons">
          <button class="btn-hacker" id="newNoteBtn" title="Create new note">
            + NEW NOTE<span class="tooltip">Create new note</span>
          </button>
          <button class="btn-hacker" id="exportBtn" title="Export encrypted backup">
            üì§<span class="tooltip">Export encrypted backup</span>
          </button>
          <button class="btn-hacker" id="exportHtmlBtn" title="Export current note as HTML">
            üì§ HTML<span class="tooltip">Export current note as HTML</span>
          </button>
          <button class="btn-hacker" id="importBtn" title="Import encrypted backup">
            üì•<span class="tooltip">Import encrypted backup</span>
          </button>
          <button class="btn-hacker" id="syncGithubBtn" title="Sync to GitHub Gist">
            ‚òÅÔ∏è GITHUB<span class="tooltip">Sync to GitHub Gist</span>
          </button>
          <button class="btn-hacker" id="clearLocalBtn" title="Destroy all local data (keep database structure)">
            üóëÔ∏è<span class="tooltip">Destroy all local data</span>
          </button>
          <button class="btn-hacker btn-danger" id="destroyDbBtn" title="Destroy entire database (for errors)">
            üí• DB<span class="tooltip">Destroy entire database</span>
          </button>
        </div>
      </div>

      <input type="text" id="searchInput" class="search-box" placeholder="SEARCH NOTES..." />

      <div class="tabs">
        <button class="tab-btn active" id="tabActive">ACTIVE NOTES</button>
        <button class="tab-btn" id="tabRecycle">üóëÔ∏è RECYCLE BIN</button>
      </div>

      <div class="note-list" id="noteList"></div>
    </div>

    <div class="main-content">
      <div class="empty-state" id="emptyState">üîç SELECT OR CREATE A NEW NOTE.</div>

      <div class="note-detail" id="noteDetail">
        <div class="note-header">
          <input type="text" class="note-title-input" id="noteTitleInput" placeholder="NOTE TITLE..." />
          <div class="note-actions">
            <button class="btn-hacker" id="deleteNoteBtn">üóëÔ∏è DELETE</button>
            <button class="btn-hacker" id="restoreNoteBtn">‚Ü©Ô∏è RESTORE</button>
            <button class="btn-hacker" id="permanentDeleteBtn">‚ùå PERMANENT DELETE</button>
            <button class="btn-hacker" id="pinNoteBtn">üìå PIN</button>
          </div>
        </div>

        <div id="editor-toolbar">
          <button class="toolbar-btn" data-command="bold" title="Bold">
            <b>B</b><span class="tooltip">Bold</span>
          </button>
          <button class="toolbar-btn" data-command="italic" title="Italic">
            <i>I</i><span class="tooltip">Italic</span>
          </button>
          <button class="toolbar-btn" data-command="underline" title="Underline">
            <u>U</u><span class="tooltip">Underline</span>
          </button>
          <button class="toolbar-btn" data-command="strikeThrough" title="Strikethrough">
            <s>S</s><span class="tooltip">Strikethrough</span>
          </button>
          <button class="toolbar-btn" data-command="subscript" title="Subscript">
            X<sub>2</sub><span class="tooltip">Subscript</span>
          </button>
          <button class="toolbar-btn" data-command="superscript" title="Superscript">
            X<sup>2</sup><span class="tooltip">Superscript</span>
          </button>
          <button class="toolbar-btn" data-command="justifyLeft" title="Align Left">
            ‚Üê<span class="tooltip">Align Left</span>
          </button>
          <button class="toolbar-btn" data-command="justifyCenter" title="Align Center">
            ‚Üî<span class="tooltip">Align Center</span>
          </button>
          <button class="toolbar-btn" data-command="justifyRight" title="Align Right">
            ‚Üí<span class="tooltip">Align Right</span>
          </button>
          <button class="toolbar-btn" data-command="justifyFull" title="Justify">
            ‚â°<span class="tooltip">Justify</span>
          </button>
          <button class="toolbar-btn" data-command="insertUnorderedList" title="Bullet List">
            ‚Ä¢<span class="tooltip">Bullet List</span>
          </button>
          <button class="toolbar-btn" data-command="insertOrderedList" title="Numbered List">
            1.<span class="tooltip">Numbered List</span>
          </button>
          <button class="toolbar-btn" data-command="createLink" title="Insert Link">
            üîó<span class="tooltip">Insert Link</span>
          </button>
          <button class="toolbar-btn" data-command="insertImage" title="Insert Image">
            üñºÔ∏è<span class="tooltip">Insert Image</span>
          </button>
          <button class="toolbar-btn" data-command="insertVideo" title="Insert Video">
            üé•<span class="tooltip">Insert Video</span>
          </button>
          <button class="toolbar-btn" data-command="insertHorizontalRule" title="Horizontal Line">
            ‚Äï<span class="tooltip">Horizontal Line</span>
          </button>
          <button class="toolbar-btn" data-command="insertTable" title="Insert Table">
            ‚ñ¶<span class="tooltip">Insert Table</span>
          </button>
          <button class="toolbar-btn" data-command="formatBlock" data-value="h1" title="Heading 1">
            H1<span class="tooltip">Heading 1</span>
          </button>
          <button class="toolbar-btn" data-command="formatBlock" data-value="h2" title="Heading 2">
            H2<span class="tooltip">Heading 2</span>
          </button>
          <button class="toolbar-btn" data-command="formatBlock" data-value="h3" title="Heading 3">
            H3<span class="tooltip">Heading 3</span>
          </button>
          <button class="toolbar-btn" data-command="formatBlock" data-value="h4" title="Heading 4">
            H4<span class="tooltip">Heading 4</span>
          </button>
          <button class="toolbar-btn" data-command="formatBlock" data-value="h5" title="Heading 5">
            H5<span class="tooltip">Heading 5</span>
          </button>
          <button class="toolbar-btn" id="codeViewBtn" title="Code View">
            {"{}"}<span class="tooltip">Code View</span>
          </button>
          <button class="toolbar-btn" data-command="undo" title="Undo">
            ‚Ü©Ô∏è<span class="tooltip">Undo</span>
          </button>
          <button class="toolbar-btn" data-command="redo" title="Redo">
            ‚Ü™Ô∏è<span class="tooltip">Redo</span>
          </button>
          <button class="toolbar-btn" data-command="removeFormat" title="Remove Formatting">
            ‚àÖ<span class="tooltip">Remove Formatting</span>
          </button>
        </div>

        <div id="editor-container">
          <div id="editor" contenteditable="true" placeholder="Start typing your secret note..."></div>
        </div>

        <div class="note-footer">
          <span id="createdAt">CREATED: ‚Äî</span>
          <span id="updatedAt">UPDATED: ‚Äî</span>
        </div>
      </div>
    </div>
  </div>

  <div class="status-bar" id="statusBar">LOADING SQLITE ENGINE...</div>
  <input type="file" id="fileInput" accept=".sqlite,.encrypted,.db" style="display:none;" />

  <!-- GITHUB MODAL -->
  <div id="githubModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.8); z-index:1000; align-items:center; justify-content:center;">
    <div style="background:#001100; border:1px solid #005500; padding:20px; width:90%; max-width:500px; font-family:'Courier New',monospace; color:#00ff00;">
      <h3 style="margin-top:0;">‚òÅÔ∏è GITHUB SYNC</h3>
      <p style="color:#00aa00; font-size:14px;">Backup/restore encrypted notes to your GitHub Gist.</p>

      <label style="display:block; margin:10px 0 5px; color:#00aa00;">PERSONAL ACCESS TOKEN</label>
      <input type="password" id="githubToken" placeholder="ghp_xxxxxxxxxxxxxxxxxxxxxx" style="width:100%; padding:8px; background:#000; border:1px solid #005500; color:#00ff00;" />

      <div style="margin-top:20px; display:flex; gap:10px;">
        <button class="btn-hacker" id="syncUploadBtn" style="flex:1;">üì§ UPLOAD</button>
        <button class="btn-hacker" id="syncDownloadBtn" style="flex:1;">üì• DOWNLOAD</button>
      </div>

      <button class="btn-hacker" id="closeModalBtn" style="margin-top:15px; width:100%;">‚ùå CLOSE</button>
    </div>
  </div>

  <!-- CONFIRMATION MODAL -->
  <div id="confirmModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.8); z-index:1000; align-items:center; justify-content:center;">
    <div style="background:#001100; border:1px solid #005500; padding:20px; width:90%; max-width:400px; font-family:'Courier New',monospace; color:#00ff00;">
      <h3 id="confirmTitle" style="margin-top:0;">üóëÔ∏è CONFIRMATION</h3>
      <p id="confirmMessage" style="color:#00aa00; font-size:14px;">Are you sure?</p>
      
      <div style="margin-top:20px; display:flex; gap:10px;">
        <button class="btn-hacker" id="confirmYesBtn" style="flex:1;">‚úÖ YES</button>
        <button class="btn-hacker" id="confirmNoBtn" style="flex:1;">‚ùå NO</button>
      </div>
    </div>
  </div>

  <script src="../assets/sql-wasm.min.js"></script>
  <script>
    let db = null;
    let currentNoteId = null;
    let currentTab = 'active';
    let autoSaveTimer = null;
    let isLoadingNote = false;
    let isCodeView = false;
    let isEventListenersAttached = false;

    // Element references
    const els = {
      noteList: document.getElementById('noteList'),
      emptyState: document.getElementById('emptyState'),
      noteDetail: document.getElementById('noteDetail'),
      titleInput: document.getElementById('noteTitleInput'),
      deleteBtn: document.getElementById('deleteNoteBtn'),
      restoreBtn: document.getElementById('restoreNoteBtn'),
      permanentDeleteBtn: document.getElementById('permanentDeleteBtn'),
      pinNoteBtn: document.getElementById('pinNoteBtn'),
      newBtn: document.getElementById('newNoteBtn'),
      exportBtn: document.getElementById('exportBtn'),
      exportHtmlBtn: document.getElementById('exportHtmlBtn'),
      importBtn: document.getElementById('importBtn'),
      syncGithubBtn: document.getElementById('syncGithubBtn'),
      clearLocalBtn: document.getElementById('clearLocalBtn'),
      destroyDbBtn: document.getElementById('destroyDbBtn'),
      searchInput: document.getElementById('searchInput'),
      statusBar: document.getElementById('statusBar'),
      tabActive: document.getElementById('tabActive'),
      tabRecycle: document.getElementById('tabRecycle'),
      createdAt: document.getElementById('createdAt'),
      updatedAt: document.getElementById('updatedAt'),
      githubModal: document.getElementById('githubModal'),
      closeModalBtn: document.getElementById('closeModalBtn'),
      syncUploadBtn: document.getElementById('syncUploadBtn'),
      syncDownloadBtn: document.getElementById('syncDownloadBtn'),
      githubToken: document.getElementById('githubToken'),
      editor: document.getElementById('editor'),
      toolbar: document.getElementById('editor-toolbar'),
      codeViewBtn: document.getElementById('codeViewBtn'),
      fileInput: document.getElementById('fileInput')
    };

    // Modal elements
    const confirmModal = document.getElementById('confirmModal');
    const confirmTitle = document.getElementById('confirmTitle');
    const confirmMessage = document.getElementById('confirmMessage');
    const confirmYesBtn = document.getElementById('confirmYesBtn');
    const confirmNoBtn = document.getElementById('confirmNoBtn');

    // Show confirmation modal
    function showConfirm(title, message, onYes) {
      confirmTitle.textContent = title;
      confirmMessage.textContent = message;
      confirmModal.style.display = 'flex';
      
      confirmYesBtn.onclick = () => {
        confirmModal.style.display = 'none';
        onYes();
      };
      
      confirmNoBtn.onclick = () => {
        confirmModal.style.display = 'none';
      };
    }

    // Initialize toolbar
    function initToolbar() {
      if (!els.toolbar) return;
      
      els.toolbar.querySelectorAll('.toolbar-btn[data-command]').forEach(btn => {
        btn.addEventListener('click', () => {
          const cmd = btn.dataset.command;
          let value = btn.dataset.value || null;
          
          if (cmd === 'createLink') {
            value = prompt('Enter URL:');
            if (!value) return;
          } else if (cmd === 'insertImage') {
            value = prompt('Enter image URL:');
            if (!value) return;
            document.execCommand('insertHTML', false, `<img src="${value}" alt="Image" style="max-width:100%;height:auto;">`);
            triggerAutoSave();
            return;
          } else if (cmd === 'insertVideo') {
            value = prompt('Enter video URL (MP4/WebM):');
            if (!value) return;
            document.execCommand('insertHTML', false, `<video src="${value}" controls style="max-width:100%;height:auto;"></video>`);
            triggerAutoSave();
            return;
          } else if (cmd === 'insertTable') {
            const rows = prompt('Rows:', '2');
            const cols = prompt('Columns:', '2');
            if (!rows || !cols) return;
            value = `<table border="1">${'<tr>' + '<td>&nbsp;</td>'.repeat(cols) + '</tr>'.repeat(rows)}</table>`;
            if (isCodeView) {
              let currentText = els.editor.textContent;
              els.editor.textContent = currentText + '\n' + value;
              triggerAutoSave();
            } else {
              document.execCommand('insertHTML', false, value);
              triggerAutoSave();
            }
            return;
          } else if (cmd === 'formatBlock') {
            // Handle heading formatting
            if (isCodeView) return;
            document.execCommand('formatBlock', false, value);
            triggerAutoSave();
            return;
          }
          
          if (isCodeView) return;
          
          if (cmd === 'undo') {
            document.execCommand('undo', false, null);
          } else if (cmd === 'redo') {
            document.execCommand('redo', false, null);
          } else {
            document.execCommand(cmd, false, value);
          }
          triggerAutoSave();
        });
      });

      if (els.codeViewBtn) {
        els.codeViewBtn.addEventListener('click', () => {
          if (isCodeView) {
            // Back to visual mode
            try {
              const tempDiv = document.createElement('div');
              tempDiv.innerHTML = els.editor.textContent;
              els.editor.innerHTML = tempDiv.innerHTML || '<br>';
            } catch (e) {
              els.editor.innerHTML = els.editor.textContent || '<br>';
            }
            els.editor.contentEditable = "true";
            els.codeViewBtn.innerHTML = '{"{}"}<span class="tooltip">Code View</span>';
            isCodeView = false;
          } else {
            // Enter code mode
            els.editor.textContent = els.editor.innerHTML;
            els.editor.contentEditable = "true";
            els.codeViewBtn.innerHTML = '{"<>"}<span class="tooltip">Visual View</span>';
            isCodeView = true;
          }
          triggerAutoSave();
          
          const toolbarBtns = els.toolbar.querySelectorAll('.toolbar-btn:not(#codeViewBtn)');
          toolbarBtns.forEach(btn => {
            if (isCodeView) {
              btn.disabled = true;
              btn.style.opacity = '0.5';
              btn.style.cursor = 'not-allowed';
            } else {
              btn.disabled = false;
              btn.style.opacity = '1';
              btn.style.cursor = 'pointer';
            }
          });
        });
      }

      function handleInput() {
        if (currentNoteId && !isLoadingNote) {
          clearTimeout(autoSaveTimer);
          autoSaveTimer = setTimeout(autoSave, 1800);
        }
      }

      if (els.editor) {
        els.editor.addEventListener('input', handleInput);
        els.editor.addEventListener('keyup', handleInput);
        els.editor.addEventListener('paste', handleInput);
      }

      if (els.editor) {
        els.editor.addEventListener('focus', () => {
          if (els.editor.innerHTML === '<br>' || els.editor.innerHTML === '') {
            els.editor.innerHTML = '';
          }
        });

        els.editor.addEventListener('blur', () => {
          if (els.editor.innerHTML.trim() === '') {
            els.editor.innerHTML = '<br>';
          }
        });
      }
    }

    // Trigger auto-save
    function triggerAutoSave() {
      if (currentNoteId && !isLoadingNote) {
        clearTimeout(autoSaveTimer);
        autoSaveTimer = setTimeout(autoSave, 1800);
      }
    }

    // Get editor content
    function getEditorContent() {
      if (!els.editor) return '';
      if (isCodeView) {
        return els.editor.textContent;
      }
      let content = els.editor.innerHTML;
      if (content === '<br>') content = '';
      return content;
    }

    // Set editor content
    function setEditorContent(html) {
      if (!els.editor) return;
      if (isCodeView) {
        els.editor.textContent = html || '';
      } else {
        els.editor.innerHTML = html || '<br>';
      }
    }

    // Format date
    function formatDate(dateStr) {
      if (!dateStr) return '‚Äî';
      return new Date(dateStr).toLocaleString('en-US', {
        day: 'numeric',
        month: 'short',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    }

    // Strip HTML
    function stripHtml(html) {
      const div = document.createElement('div');
      div.innerHTML = html;
      return div.textContent || div.innerText || '';
    }

    // Escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text || '';
      return div.innerHTML;
    }

    // Encrypt data
    async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey("raw", encoder.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]);
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const key = await crypto.subtle.deriveKey({ name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt"]);
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, data);
      const result = new Uint8Array(29 + encrypted.byteLength);
      result[0] = 1;
      result.set(salt, 1);
      result.set(iv, 17);
      result.set(new Uint8Array(encrypted), 29);
      return result;
    }

    // Decrypt data
    async function decryptData(encryptedData, password) {
      if (encryptedData[0] !== 1) throw new Error("Unsupported format");
      const salt = encryptedData.slice(1, 17);
      const iv = encryptedData.slice(17, 29);
      const encrypted = encryptedData.slice(29);
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey("raw", encoder.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]);
      const key = await crypto.subtle.deriveKey({ name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["decrypt"]);
      const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, encrypted);
      return new Uint8Array(decrypted);
    }

    // IndexedDB constants
    const DB_NAME = 'sqlite-notes-db';
    const STORE_NAME = 'database';

    // Save to IndexedDB
    function saveToIndexedDB(data) {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = () => req.result.createObjectStore(STORE_NAME);
        req.onsuccess = () => {
          const tx = req.result.transaction(STORE_NAME, 'readwrite');
          tx.objectStore(STORE_NAME).put(data, 'main');
          tx.oncomplete = resolve;
          tx.onerror = () => reject(tx.error);
        };
        req.onerror = () => reject(req.error);
      });
    }

    // Load from IndexedDB
    function loadFromIndexedDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = () => req.result.createObjectStore(STORE_NAME);
        req.onsuccess = () => {
          const tx = req.result.transaction(STORE_NAME, 'readonly');
          const getReq = tx.objectStore(STORE_NAME).get('main');
          getReq.onsuccess = () => resolve(getReq.result || null);
          getReq.onerror = () => reject(getReq.error);
        };
        req.onerror = () => reject(req.error);
      });
    }

    // Clear IndexedDB
    async function clearIndexedDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.deleteDatabase(DB_NAME);
        req.onsuccess = resolve;
        req.onerror = () => reject(req.error);
      });
    }

    // Auto-save function
    function autoSave() {
      if (!db || !currentNoteId || isLoadingNote) return;
      try {
        const title = els.titleInput.value.trim() || '(untitled)';
        const content = getEditorContent();
        const now = new Date().toISOString();
        
        db.run("UPDATE notes SET title = ?, content = ?, updated_at = ? WHERE id = ?", [title, content, now, currentNoteId]);
        saveToIndexedDB(db.export()).catch(console.error);
        
        els.updatedAt.textContent = `UPDATED: ${formatDate(now)}`;
        els.statusBar.textContent = '‚úÖ SAVED';
        setTimeout(() => { els.statusBar.textContent = ''; }, 1200);
        
        renderNoteList(els.searchInput.value);
        
      } catch (err) {
        console.error('Auto-save error:', err);
        els.statusBar.textContent = '‚ùå SAVE FAILED';
        setTimeout(() => { els.statusBar.textContent = ''; }, 2000);
      }
    }

    // Ensure database schema
    async function ensureSchema(SQL) {
      let hasTable = false;
      try {
        const stmt = db.prepare("SELECT name FROM sqlite_master WHERE type='table' AND name='notes'");
        hasTable = !!stmt.step();
        stmt.free();
      } catch {}

      if (!hasTable) {
        db.run(`
          CREATE TABLE notes (
            id INTEGER PRIMARY KEY,
            title TEXT NOT NULL,
            content TEXT,
            created_at DATETIME,
            updated_at DATETIME,
            deleted_at DATETIME,
            is_pinned BOOLEAN DEFAULT 0
          )
        `);
        return;
      }

      // Check existing columns
      const pragma = db.prepare("PRAGMA table_info(notes)");
      const columns = new Set();
      while (pragma.step()) {
        columns.add(pragma.getAsObject().name);
      }
      pragma.free();

      // Add missing columns
      if (!columns.has('updated_at')) {
        db.run("ALTER TABLE notes ADD COLUMN updated_at DATETIME");
        db.run("UPDATE notes SET updated_at = created_at WHERE updated_at IS NULL");
      }
      if (!columns.has('deleted_at')) {
        db.run("ALTER TABLE notes ADD COLUMN deleted_at DATETIME");
      }
      if (!columns.has('is_pinned')) {
        db.run("ALTER TABLE notes ADD COLUMN is_pinned BOOLEAN DEFAULT 0");
      }
    }

    // Render note list
    function renderNoteList(search = '') {
      if (!db) return;
      
      let where = currentTab === 'active' ? "deleted_at IS NULL" : "deleted_at IS NOT NULL";
      let query = `SELECT id, title, content, updated_at, is_pinned FROM notes WHERE ${where}`;
      const params = [];
      if (search.trim()) {
        query += " AND (title LIKE ? OR content LIKE ?)";
        const term = `%${search.trim()}%`;
        params.push(term, term);
      }
      query += " ORDER BY is_pinned DESC, updated_at DESC";

      const stmt = db.prepare(query);
      if (params.length) stmt.bind(params);
      const rows = [];
      while (stmt.step()) rows.push(stmt.getAsObject());
      stmt.free();

      els.noteList.innerHTML = '';
      if (rows.length === 0) {
        els.noteList.innerHTML = `<div style="padding:40px;text-align:center;color:#00aa00;">
          ${currentTab === 'active' ? 'NO NOTES FOUND' : 'RECYCLE BIN IS EMPTY'}
        </div>`;
        return;
      }

      rows.forEach(row => {
        const item = document.createElement('div');
        item.className = `note-item${row.id == currentNoteId ? ' selected' : ''}${row.is_pinned ? ' pinned' : ''}`;
        item.dataset.id = row.id;
        const preview = stripHtml(row.content || '');
        item.innerHTML = `
          <span class="pinned-indicator">üìå</span>
          <div class="note-title">${escapeHtml(row.title)}</div>
          <div class="note-preview">${escapeHtml(preview)}</div>
          <div class="note-meta"><span></span><span>${formatDate(row.updated_at)}</span></div>
        `;
        els.noteList.appendChild(item);
      });

      document.querySelectorAll('.note-item').forEach(item => {
        item.removeEventListener('click', handleNoteItemClick);
        item.addEventListener('click', handleNoteItemClick);
      });
    }

    // Handle note item click
    function handleNoteItemClick(e) {
      const id = parseInt(e.currentTarget.dataset.id);
      loadNote(id);
    }

    // Load note
    function loadNote(id) {
      clearTimeout(autoSaveTimer);
      
      // Remove selected class from all notes
      document.querySelectorAll('.note-item').forEach(item => {
        item.classList.remove('selected');
      });
      
      const stmt = db.prepare("SELECT * FROM notes WHERE id = ?");
      stmt.bind([id]);
      if (stmt.step()) {
        const row = stmt.getAsObject();
        currentNoteId = id;
        els.titleInput.value = row.title;
        isLoadingNote = true;
        setEditorContent(row.content || '');
        isLoadingNote = false;
        els.createdAt.textContent = `CREATED: ${formatDate(row.created_at)}`;
        els.updatedAt.textContent = `UPDATED: ${formatDate(row.updated_at)}`;
        els.emptyState.style.display = 'none';
        els.noteDetail.style.display = 'flex';
        updateActionButtons();
        renderNoteList(els.searchInput.value);
        
        // Add selected class to current note
        const currentItem = document.querySelector(`.note-item[data-id="${id}"]`);
        if (currentItem) {
          currentItem.classList.add('selected');
        }
      }
      stmt.free();
    }

    // Update action buttons
    function updateActionButtons() {
      if (currentTab === 'recycle') {
        els.deleteBtn.style.display = 'none';
        els.restoreBtn.style.display = 'block';
        els.permanentDeleteBtn.style.display = 'block';
        els.pinNoteBtn.style.display = 'none';
      } else {
        els.deleteBtn.style.display = 'block';
        els.restoreBtn.style.display = 'none';
        els.permanentDeleteBtn.style.display = 'none';
        els.pinNoteBtn.style.display = 'block';
        const stmt = db.prepare("SELECT is_pinned FROM notes WHERE id = ?");
        stmt.bind([currentNoteId]);
        if (stmt.step()) {
          const isPinned = stmt.getAsObject().is_pinned;
          els.pinNoteBtn.textContent = isPinned ? 'üìå UNPIN' : 'üìå PIN';
        }
        stmt.free();
      }
    }

    // Hide note detail
    function hideNoteDetail() {
      els.emptyState.style.display = 'flex';
      els.noteDetail.style.display = 'none';
      currentNoteId = null;
      els.titleInput.value = '';
      setEditorContent('');
      els.createdAt.textContent = 'CREATED: ‚Äî';
      els.updatedAt.textContent = 'UPDATED: ‚Äî';
      renderNoteList(els.searchInput.value);
    }

    // Restore note
    function restoreNote() {
      showConfirm('‚Ü©Ô∏è RESTORE', 'Restore this note to Active Notes?', () => {
        db.run("UPDATE notes SET deleted_at = NULL WHERE id = ?", [currentNoteId]);
        autoSave();
        hideNoteDetail();
        els.statusBar.textContent = '‚Ü©Ô∏è RESTORED TO ACTIVE NOTES';
        setTimeout(() => { els.statusBar.textContent = ''; }, 2000);
        switchTab('active');
      });
    }

    // Permanent delete note
    function permanentDeleteNote() {
      showConfirm('‚ùå PERMANENT DELETE', 'This cannot be undone!', () => {
        db.run("DELETE FROM notes WHERE id = ?", [currentNoteId]);
        autoSave();
        hideNoteDetail();
        els.statusBar.textContent = '‚ùå PERMANENTLY DELETED';
        setTimeout(() => { els.statusBar.textContent = ''; }, 2000);
        renderNoteList(els.searchInput.value);
      });
    }

    // Delete current note (move to recycle bin)
    function deleteCurrentNote() {
      showConfirm('üóëÔ∏è MOVE TO RECYCLE BIN', 'This note will be moved to Recycle Bin.', () => {
        const now = new Date().toISOString();
        // Automatically unpin when moving to recycle bin
        db.run("UPDATE notes SET deleted_at = ?, is_pinned = 0 WHERE id = ?", [now, currentNoteId]);
        autoSave();
        hideNoteDetail();
        els.statusBar.textContent = 'üóëÔ∏è MOVED TO RECYCLE BIN';
        setTimeout(() => { els.statusBar.textContent = ''; }, 2000);
        renderNoteList(els.searchInput.value);
      });
    }

    // Toggle pin note
    function togglePinNote() {
      if (!currentNoteId) return;
      
      const stmt = db.prepare("SELECT is_pinned FROM notes WHERE id = ?");
      stmt.bind([currentNoteId]);
      let isCurrentlyPinned = false;
      if (stmt.step()) {
        isCurrentlyPinned = stmt.getAsObject().is_pinned;
      }
      stmt.free();
      
      if (isCurrentlyPinned) {
        // Unpin
        db.run("UPDATE notes SET is_pinned = 0 WHERE id = ?", [currentNoteId]);
        autoSave();
        els.statusBar.textContent = 'üìå UNPINNED';
        setTimeout(() => { els.statusBar.textContent = ''; }, 2000);
        renderNoteList(els.searchInput.value);
        updateActionButtons(); // Update button immediately
      } else {
        // Check if there's already a pinned note
        const checkStmt = db.prepare("SELECT COUNT(*) as count FROM notes WHERE is_pinned = 1 AND deleted_at IS NULL");
        let hasPinned = false;
        if (checkStmt.step()) {
          hasPinned = checkStmt.getAsObject().count > 0;
        }
        checkStmt.free();
        
        if (hasPinned) {
          showConfirm('üìå PIN NOTE', 'Replace current pinned note?', () => {
            db.run("UPDATE notes SET is_pinned = 0 WHERE is_pinned = 1");
            db.run("UPDATE notes SET is_pinned = 1 WHERE id = ?", [currentNoteId]);
            autoSave();
            els.statusBar.textContent = 'üìå PINNED (REPLACED)';
            setTimeout(() => { els.statusBar.textContent = ''; }, 2000);
            renderNoteList(els.searchInput.value);
            updateActionButtons(); // Update button immediately
          });
        } else {
          db.run("UPDATE notes SET is_pinned = 1 WHERE id = ?", [currentNoteId]);
          autoSave();
          els.statusBar.textContent = 'üìå PINNED';
          setTimeout(() => { els.statusBar.textContent = ''; }, 2000);
          renderNoteList(els.searchInput.value);
          updateActionButtons(); // Update button immediately
        }
      }
    }

    // Handle export current note as HTML (as-is)
    function handleExportHtml() {
      if (!currentNoteId) {
        els.statusBar.textContent = '‚ùå NO NOTE SELECTED';
        setTimeout(() => { els.statusBar.textContent = ''; }, 2000);
        return;
      }
      
      const title = els.titleInput.value.trim() || '(untitled)';
      const content = getEditorContent();
      const createdAt = els.createdAt.textContent.replace('CREATED: ', '');
      const updatedAt = els.updatedAt.textContent.replace('UPDATED: ', '');
      
      // Buat HTML as-is dengan footer metadata
      const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${escapeHtml(title)}</title>
</head>
<body>
  <h1>${escapeHtml(title)}</h1>
  ${content}
  <hr>
  <p><small>Created: ${createdAt}</small></p>
  <p><small>Updated: ${updatedAt}</small></p>
  <p><small>Created by <a href="https://github.com/jeannesbryan/jeannesbryan.github.io/tree/main/secretnotes" target="_blank">SecretNotes</a></small></p>
</body>
</html>`;

      // Download file
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      // Sanitize filename
      const safeTitle = title.replace(/[^a-z0-9]/gi, '_').substring(0, 50) || 'note';
      a.download = `${safeTitle}.html`;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 0);
      
      els.statusBar.textContent = '‚úÖ HTML EXPORTED!';
      setTimeout(() => { els.statusBar.textContent = ''; }, 2000);
    }

    // Initialize modals
    function initModal() {
      if (els.githubModal) els.githubModal.style.display = 'none';

      if (els.syncGithubBtn) {
        els.syncGithubBtn.addEventListener('click', () => {
          if (els.githubModal) els.githubModal.style.display = 'flex';
        });
      }

      if (els.closeModalBtn) {
        els.closeModalBtn.addEventListener('click', () => {
          if (els.githubModal) els.githubModal.style.display = 'none';
        });
      }

      if (els.githubModal) {
        els.githubModal.addEventListener('click', (e) => {
          if (e.target === els.githubModal) {
            els.githubModal.style.display = 'none';
          }
        });
      }
    }

    // Handle new note
    function handleNewNote() {
      const now = new Date().toISOString();
      db.run("INSERT INTO notes (title, content, created_at, updated_at) VALUES (?, ?, ?, ?)", ['NEW NOTE', '', now, now]);
      
      const stmt = db.prepare("SELECT last_insert_rowid() as id");
      stmt.step();
      const id = stmt.getAsObject().id;
      stmt.free();
      
      renderNoteList(els.searchInput.value);
      
      setTimeout(() => {
        loadNote(id);
      }, 100);
    }

    // Handle export
    async function handleExport() {
      if (!db) return;
      try {
        const data = db.export();
        const password = prompt("ENTER PASSWORD FOR ENCRYPTED BACKUP:");
        if (!password) return;
        const encrypted = await encryptData(data, password);
        const blob = new Blob([encrypted], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'secretnotes.encrypted';
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }, 0);
        els.statusBar.textContent = '‚úÖ ENCRYPTED FILE SAVED!';
        setTimeout(() => { els.statusBar.textContent = ''; }, 2000);
      } catch (err) {
        alert('EXPORT FAILED: ' + err.message);
      }
    }

    // Handle file import
    async function handleFileImport(e) {
      const file = e.target.files[0];
      if (!file) return;
      try {
        const arrayBuffer = await file.arrayBuffer();
        let dbData;
        
        const uint8 = new Uint8Array(arrayBuffer);
        const isEncrypted = file.name.endsWith('.encrypted') || uint8[0] === 1;
        
        if (isEncrypted) {
          const password = prompt("ENTER PASSWORD TO DECRYPT:");
          if (!password) return;
          dbData = await decryptData(uint8, password);
        } else {
          dbData = uint8;
        }
        
        const SQL = await initSqlJs({
          locateFile: filename => `../assets/${filename}`
        });
        db = new SQL.Database(dbData);
        await ensureSchema(SQL);
        await saveToIndexedDB(dbData);
        autoSave();
        renderNoteList();
        els.statusBar.textContent = '‚úÖ DATABASE LOADED & SAVED!';
        setTimeout(() => { els.statusBar.textContent = ''; }, 2000);
      } catch (err) {
        console.error('Import error:', err);
        els.statusBar.textContent = '‚ùå FAILED: ' + (err.message || 'WRONG PASSWORD / CORRUPT FILE');
        setTimeout(() => { els.statusBar.textContent = ''; }, 3000);
      }
      e.target.value = '';
    }

    // Handle destroy local data (keep database structure)
    async function handleDestroy() {
      if (confirm('DESTROY ALL LOCAL DATA? THIS WILL CREATE A FRESH DATABASE.\n\nBACKUP FILES (.encrypted) REMAIN SAFE.')) {
        try {
          await clearIndexedDB();
          
          const SQL = await initSqlJs({
            locateFile: filename => `../assets/${filename}`
          });
          
          db = new SQL.Database();
          await ensureSchema(SQL);
          const data = db.export();
          await saveToIndexedDB(data);
          
          currentNoteId = null;
          els.titleInput.value = '';
          setEditorContent('');
          els.createdAt.textContent = 'CREATED: ‚Äî';
          els.updatedAt.textContent = 'UPDATED: ‚Äî';
          
          els.noteList.innerHTML = '';
          els.emptyState.style.display = 'flex';
          els.noteDetail.style.display = 'none';
          
          renderNoteList();
          
          els.statusBar.textContent = '‚úÖ LOCAL DATA DESTROYED. NEW DATABASE READY.';
          setTimeout(() => { els.statusBar.textContent = ''; }, 3000);
        } catch (err) {
          console.error('Destroy failed:', err);
          alert('FAILED TO DESTROY DATA: ' + err.message);
        }
      }
    }

    // Handle destroy entire database (for schema errors)
    async function handleDestroyDatabase() {
      if (confirm('DESTROY ENTIRE DATABASE?\n\nThis will delete ALL data including schema.\nUse only if you see database errors like "no such column".')) {
        try {
          // Hapus IndexedDB sepenuhnya
          await clearIndexedDB();
          
          // Reset variabel global
          db = null;
          currentNoteId = null;
          
          // Clear gist ID
          localStorage.removeItem('secretnotes_gist_id');
          
          // Reset UI
          els.noteList.innerHTML = '';
          els.emptyState.style.display = 'flex';
          els.noteDetail.style.display = 'none';
          els.titleInput.value = '';
          setEditorContent('');
          els.createdAt.textContent = 'CREATED: ‚Äî';
          els.updatedAt.textContent = 'UPDATED: ‚Äî';
          
          els.statusBar.textContent = 'üí• DATABASE DESTROYED. Refresh to create new database.';
          setTimeout(() => { els.statusBar.textContent = ''; }, 3000);
          
        } catch (err) {
          console.error('Destroy database failed:', err);
          alert('FAILED TO DESTROY DATABASE: ' + err.message);
        }
      }
    }

    // Handle search
    function handleSearch(e) {
      renderNoteList(e.target.value.trim());
    }

    // Switch tab
    function switchTab(tab) {
      currentTab = tab;
      els.tabActive.classList.toggle('active', tab === 'active');
      els.tabRecycle.classList.toggle('active', tab === 'recycle');
      renderNoteList(els.searchInput.value);
    }

    // Handle title input
    function handleTitleInput() {
      if (currentNoteId) {
        clearTimeout(autoSaveTimer);
        autoSaveTimer = setTimeout(autoSave, 1800);
      }
    }

    // Close modal
    function closeModal() {
      if (els.githubModal) els.githubModal.style.display = 'none';
    }

    // GitHub API URL
    const GITHUB_API_URL = 'https://api.github.com';
    let gistId = localStorage.getItem('secretnotes_gist_id');

    // Upload to GitHub
    async function uploadToGitHub(token, data) {
      const password = prompt("ENTER PASSWORD TO ENCRYPT BACKUP:");
      if (!password) throw new Error("Password required");
      
      const encryptedData = await encryptData(data, password);
      const fileName = 'secretnotes.db.encrypted';
      const base64Data = btoa(String.fromCharCode(...new Uint8Array(encryptedData)));
      
      let response;
      if (gistId) {
        const updateUrl = `${GITHUB_API_URL}/gists/${gistId}`;
        response = await fetch(updateUrl, {
          method: 'PATCH',
          headers: { 
            'Authorization': `token ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            description: "SecretNotes Backup",
            files: {
              [fileName]: {
                content: base64Data
              }
            }
          })
        });
      } else {
        const createUrl = `${GITHUB_API_URL}/gists`;
        response = await fetch(createUrl, {
          method: 'POST',
          headers: { 
            'Authorization': `token ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            description: "SecretNotes Backup",
            public: false,
            files: {
              [fileName]: {
                content: base64Data
              }
            }
          })
        });
      }
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(`Upload failed: ${error.message || response.status}`);
      }
      
      const gistData = await response.json();
      gistId = gistData.id;
      localStorage.setItem('secretnotes_gist_id', gistId);
      return true;
    }

    // Download from GitHub
    async function downloadFromGitHub(token) {
      if (!gistId) {
        throw new Error('No backup found. Please upload first.');
      }
      
      const url = `${GITHUB_API_URL}/gists/${gistId}`;
      const response = await fetch(url, {
        headers: { 'Authorization': `token ${token}` }
      });
      
      if (!response.ok) {
        if (response.status === 404) throw new Error('Backup not found');
        if (response.status === 401) throw new Error('Invalid token');
        throw new Error(`Download failed: ${response.status}`);
      }
      
      const data = await response.json();
      const fileName = 'secretnotes.db.encrypted';
      const file = data.files[fileName];
      
      if (!file) throw new Error('Backup file not found in Gist');
      
      const binaryString = atob(file.content);
      const encryptedData = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        encryptedData[i] = binaryString.charCodeAt(i);
      }
      
      const password = prompt("ENTER PASSWORD TO DECRYPT BACKUP:");
      if (!password) throw new Error("Password required");
      
      return await decryptData(encryptedData, password);
    }

    // Handle upload
    async function handleUpload() {
      const token = els.githubToken.value.trim();
      
      if (!token) {
        alert('Please enter your token!');
        return;
      }
      
      try {
        els.statusBar.textContent = '‚òÅÔ∏è Uploading to GitHub...';
        const data = db.export();
        await uploadToGitHub(token, data);
        els.statusBar.textContent = '‚úÖ Successfully synced to GitHub!';
        setTimeout(() => { els.statusBar.textContent = ''; }, 3000);
        els.githubModal.style.display = 'none';
      } catch (err) {
        console.error('Sync error:', err);
        els.statusBar.textContent = `‚ùå Sync failed: ${err.message}`;
        setTimeout(() => { els.statusBar.textContent = ''; }, 5000);
      }
    }

    // Handle download
    function handleDownload() {
      const token = els.githubToken.value.trim();
      
      if (!token) {
        alert('Please enter your token!');
        return;
      }
      
      els.statusBar.textContent = '‚òÅÔ∏è Downloading from GitHub...';
      
      downloadFromGitHub(token)
        .then(async (dbData) => {
          try {
            const SQL = await initSqlJs({ 
              locateFile: (filename) => `../assets/${filename}` 
            });
            
            db = new SQL.Database(dbData);
            await ensureSchema(SQL);
            await saveToIndexedDB(dbData);
            autoSave();
            renderNoteList();
            
            els.statusBar.textContent = '‚úÖ Restored from GitHub!';
            setTimeout(() => { els.statusBar.textContent = ''; }, 3000);
            els.githubModal.style.display = 'none';
          } catch (err) {
            throw err;
          }
        })
        .catch(err => {
          console.error('Restore error:', err);
          els.statusBar.textContent = `‚ùå Restore failed: ${err.message}`;
          setTimeout(() => { els.statusBar.textContent = ''; }, 5000);
        });
    }

    // Attach event listeners
    function attachEventListeners() {
      if (isEventListenersAttached) return;
      
      els.newBtn.addEventListener('click', handleNewNote);
      els.exportBtn.addEventListener('click', handleExport);
      els.exportHtmlBtn.addEventListener('click', handleExportHtml);
      els.importBtn.addEventListener('click', () => els.fileInput.click());
      els.clearLocalBtn.addEventListener('click', handleDestroy);
      els.destroyDbBtn.addEventListener('click', handleDestroyDatabase);
      els.syncGithubBtn.addEventListener('click', () => {
        if (els.githubModal) els.githubModal.style.display = 'flex';
      });
      
      els.searchInput.addEventListener('input', handleSearch);
      els.tabActive.addEventListener('click', () => switchTab('active'));
      els.tabRecycle.addEventListener('click', () => switchTab('recycle'));
      els.titleInput.addEventListener('input', handleTitleInput);
      
      els.closeModalBtn.addEventListener('click', closeModal);
      els.githubModal?.addEventListener('click', (e) => {
        if (e.target === els.githubModal) closeModal();
      });
      
      els.fileInput.addEventListener('change', handleFileImport);
      
      els.syncUploadBtn.addEventListener('click', handleUpload);
      els.syncDownloadBtn.addEventListener('click', handleDownload);
      
      els.deleteBtn.addEventListener('click', deleteCurrentNote);
      els.restoreBtn.addEventListener('click', restoreNote);
      els.permanentDeleteBtn.addEventListener('click', permanentDeleteNote);
      els.pinNoteBtn.addEventListener('click', togglePinNote);
      
      isEventListenersAttached = true;
    }

    // Initialize app
    async function initApp() {
      try {
        els.statusBar.textContent = 'Loading SQLite engine...';
        
        const SQL = await initSqlJs({ 
          locateFile: (f) => `../assets/${f}` 
        });
        
        let savedData = null;
        try {
          savedData = await loadFromIndexedDB();
        } catch (err) {
          console.warn('No saved data found, creating new database');
        }
        
        if (savedData) {
          db = new SQL.Database(savedData);
          await ensureSchema(SQL);
        } else {
          db = new SQL.Database();
          db.run(`
            CREATE TABLE IF NOT EXISTS notes (
              id INTEGER PRIMARY KEY,
              title TEXT NOT NULL,
              content TEXT,
              created_at DATETIME,
              updated_at DATETIME,
              deleted_at DATETIME,
              is_pinned BOOLEAN DEFAULT 0
            )
          `);
        }
        
        renderNoteList();
        initToolbar();
        attachEventListeners();
        
        els.statusBar.textContent = '‚úÖ SecretNotes ready!';
        
      } catch (err) {
        console.error('Init error:', err);
        els.statusBar.textContent = '‚ùå Failed: ' + (err.message || 'Unknown error');
      }
    }

    // Service worker registration
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js').catch(console.error);
      });
    }

    // DOM ready
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => {
        initApp();
      }, 100);
    });
  </script>
</body>
</html>